"""
Celery tasks for scheduled operations.
"""
from celery import Task
from datetime import datetime
from sqlalchemy.orm import Session
import uuid

from src.models.base import SessionLocal
from src.models.signals import Signal
from src.core.signal_scorer import SignalScorer
from src.data.stock_act import StockActFetcher
from src.utils.logging import get_logger
from src.scheduler.celery_app import app

logger = get_logger(__name__)


class DatabaseTask(Task):
    """Base task with database session."""
    _db = None
    
    @property
    def db(self) -> Session:
        if self._db is None:
            self._db = SessionLocal()
        return self._db


@app.task(base=DatabaseTask, bind=True)
def ingest_all_data(self):
    """
    Daily task: Fetch data from all sources.
    Runs at 6 AM UTC.
    """
    logger.info("Starting data ingestion")
    
    db = self.db
    
    try:
        # Fetch congressional trades
        stock_act_fetcher = StockActFetcher()
        trades = stock_act_fetcher.fetch_recent_trades()
        signals_data = stock_act_fetcher.transform_to_signal_format(trades)
        
        logger.info(f"StockAct: {len(signals_data)} signals fetched")
        
        # Fetch OpenInsider congressional trades
        from src.data.openinsider import OpenInsiderFetcher
        oi_fetcher = OpenInsiderFetcher()
        oi_trades = oi_fetcher.fetch_congressional_trades(limit=100)
        oi_signals = oi_fetcher.transform_to_signal_format(oi_trades)
        logger.info(f"OpenInsider: {len(oi_signals)} congressional signals")
        
        # Combine all signals
        all_signals = signals_data + oi_signals
        
        # Store signals in database
        added = 0
        duplicates = 0
        
        for signal_data in all_signals:
            # Check if already exists
            existing = db.query(Signal).filter(
                Signal.symbol == signal_data['symbol'],
                Signal.source == signal_data['source'],
                Signal.transaction_date == signal_data['transaction_date']
            ).first()
            
            if existing:
                duplicates += 1
                continue
            
            # Create signal
            signal_id = f"{signal_data['source']}_{signal_data['symbol']}_{uuid.uuid4().hex[:8]}"
            
            signal = Signal(
                signal_id=signal_id,
                source=signal_data['source'],
                symbol=signal_data['symbol'],
                direction=signal_data['direction'],
                filer_name=signal_data['filer_name'],
                transaction_date=signal_data['transaction_date'],
                filing_date=signal_data['filing_date'],
                transaction_value=signal_data['transaction_value'],
                status='PENDING',
                raw_data=signal_data.get('raw_data', {})
            )
            
            db.add(signal)
            added += 1
        
        db.commit()
        
        logger.info(f"Data ingestion complete: {added} added, {duplicates} duplicates")
        
        return {"added": added, "duplicates": duplicates}
    
    except Exception as e:
        logger.error(f"Data ingestion failed: {e}")
        db.rollback()
        raise


@app.task(base=DatabaseTask, bind=True)
def score_all_signals(self):
    """
    Daily task: Score all pending signals.
    Runs at 7 AM UTC.
    """
    logger.info("Starting signal scoring")
    
    db = self.db
    scorer = SignalScorer(db)
    
    try:
        # Get all pending signals
        pending_signals = db.query(Signal).filter(
            Signal.status == 'PENDING'
        ).all()
        
        logger.info(f"Scoring {len(pending_signals)} pending signals")
        
        scored = 0
        rejected = 0
        
        for signal in pending_signals:
            # Get similar signals for consensus scoring
            similar_signals = db.query(Signal).filter(
                Signal.symbol == signal.symbol,
                Signal.direction == signal.direction,
                Signal.status == 'ACTIVE'
            ).all()
            
            # Score signal
            try:
                factors = scorer.score_signal(
                    signal={
                        'signal_id': signal.signal_id,
                        'filing_date': signal.filing_date,
                        'transaction_value': float(signal.transaction_value),
                        'symbol': signal.symbol,
                        'filer_cik': None
                    },
                    similar_signals=similar_signals,
                    filer_history=None
                )
                
                # Update scores
                signal.recency_score = factors.recency_score
                signal.size_score = factors.size_score
                signal.competence_score = factors.competence_score
                signal.consensus_score = factors.consensus_score
                signal.regime_score = factors.regime_score
                
                total_score = scorer.calculate_total_score(factors)
                signal.total_score = total_score
                
                tier = scorer.assign_tier(total_score)
                signal.conviction_tier = tier
                
                if tier == 'REJECT':
                    signal.status = 'REJECTED'
                    rejected += 1
                else:
                    signal.status = 'ACTIVE'
                    scored += 1
                
            except Exception as e:
                logger.error(f"Error scoring signal {signal.signal_id}: {e}")
                continue
        
        db.commit()
        
        logger.info(f"Signal scoring complete: {scored} scored, {rejected} rejected")
        
        return {"scored": scored, "rejected": rejected}
    
    except Exception as e:
        logger.error(f"Signal scoring failed: {e}")
        db.rollback()
        raise


@app.task(base=DatabaseTask, bind=True)
def allocate_and_execute(self):
    """
    Daily task: Allocate capital and execute trades.
    Runs at 8 AM UTC.
    """
    logger.info("Starting allocation and execution")
    
    # TODO: Implement allocation and execution logic
    # This will be added later when we integrate the full system
    
    return {"message": "Not yet implemented"}


@app.task(base=DatabaseTask, bind=True)
def check_positions(self):
    """
    Hourly task: Check position expiry and risks.
    """
    logger.info("Checking positions")
    
    # TODO: Implement position monitoring
    # - Check round expiry
    # - Force close expired positions
    # - Monitor stop losses
    
    return {"message": "Not yet implemented"}


@app.task(base=DatabaseTask, bind=True)
def end_of_day_reconciliation(self):
    """
    Daily task: End of day portfolio reconciliation.
    Runs at 10 PM UTC.
    """
    logger.info("Starting end of day reconciliation")
    
    # TODO: Implement EOD reconciliation
    # - Portfolio snapshot
    # - Update philosophy state
    # - Calculate allocation power
    
    return {"message": "Not yet implemented"}
